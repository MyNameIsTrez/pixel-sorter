#include "cnpy.h"

#include <algorithm>
#include <filesystem>
#include <getopt.h>
#include <iomanip>
#include <random>
#include <signal.h>

class Args
{
public:
	Args(int argc, char *argv[])
		: seconds_between_prints(1), seconds_between_saves(10), kernel_radius(100), no_overwriting_output(false), saved_image_leading_zero_count(4), sort_minority_threshold(5), input_npy_path(), output_npy_path()
	{
		int c;

		char *program_name = argv[0];

		while (true)
		{
			int option_index = 0;
			static option long_options[] = {
				{"help", no_argument, 0, 'h'},
				{"seconds-between-prints", required_argument, 0, 'p'},
				{"seconds-between-saves", required_argument, 0, 's'},
				{"kernel-radius", required_argument, 0, 'k'},
				{"no-overwriting-output", no_argument, 0, 'n'},
				{"saved-image-leading-zero-count", required_argument, 0, 'z'},
				{"sort-minority-threshold", required_argument, 0, 'm'},
				{0, 0, 0, 0}};

			c = getopt_long(argc, argv, "hi:s:k:nz:w:", long_options, &option_index);

			// Detect the end of the options
			if (c == -1)
			{
				break;
			}

			switch (c)
			{
			case 'h':
				print_help(program_name);
				exit(EXIT_FAILURE);

			case 'p':
				seconds_between_prints = std::stoi(optarg);
				break;

			case 's':
				seconds_between_saves = std::stoi(optarg);
				break;

			case 'k':
				kernel_radius = std::stoi(optarg);
				break;

			case 'n':
				no_overwriting_output = true;
				break;

			case 'z':
				saved_image_leading_zero_count = std::stoi(optarg);
				break;

			case 'm':
				sort_minority_threshold = std::stod(optarg);
				break;

			case '?':
				// getopt_long() already printed an error message
				exit(EXIT_FAILURE);

			default:
				abort();
			}
		}

		// If not exactly two positional arguments were provided
		if (optind != argc - 2)
		{
			print_help(program_name);
			exit(EXIT_FAILURE);
		}

		input_npy_path = argv[argc - 2];
		output_npy_path = argv[argc - 1];
	}

	int seconds_between_prints;
	int seconds_between_saves;
	int kernel_radius;
	bool no_overwriting_output;
	int saved_image_leading_zero_count;
	double sort_minority_threshold;
	std::filesystem::path input_npy_path;
	std::filesystem::path output_npy_path;

private:
	void print_help(char *program_name)
	{
		std::cerr
			<< "Usage: " << program_name << " input_npy_path output_npy_path [-h] [-s SECONDS_BETWEEN_SAVES] [-k KERNEL_RADIUS] [-n] [-z SAVED_IMAGE_LEADING_ZERO_COUNT]\n\n";

		std::cerr
			<< "positional arguments:\n"
			   "  input_npy_path        Input npy file path, generated by for example rgb2lab.py\n"
			   "  output_npy_path       Output npy file path, which can then be used by for example lab2rgb.py\n\n";

		std::cerr
			<< "options:\n"
			   "  -h, --help            show this help message and exit\n"
			   "  -s SECONDS_BETWEEN_PRINTS, --seconds-between-prints SECONDS_BETWEEN_PRINTS\n"
			   "                        How often the status is printed (default: 1)\n"
			   "  -s SECONDS_BETWEEN_SAVES, --seconds-between-saves SECONDS_BETWEEN_SAVES\n"
			   "                        How often the current output image gets saved (default: 10)\n"
			   "  -k KERNEL_RADIUS, --kernel-radius KERNEL_RADIUS\n"
			   "                        The radius of neighbors that get compared against the current pixel's color; a higher radius means better sorting, but is quadratically slower (default: 100)\n"
			   "  -n, --no-overwriting-output\n"
			   "                        Save all output images, instead of the default behavior of overwriting (default: False)\n"
			   "  -z SAVED_IMAGE_LEADING_ZERO_COUNT, --saved-image-leading-zero-count SAVED_IMAGE_LEADING_ZERO_COUNT\n"
			   "                        The number of leading zeros on saved images; this has no effect if the -n switch isn't passed! (default: 4)\n"
			   "  -m SORT_MINORITY_THRESHOLD, --sort-minority-threshold SORT_MINORITY_THRESHOLD\n"
			   "                        The attempted_swaps / swaps after which sort_minority() will be used, which gradually gets faster the rarer swapping becomes. It is faster than sort_majority() when KERNEL_RADIUS is small (default: 5)\n";
	}
};

struct xy
{
	int x;
	int y;

	xy operator+(const xy &other)
	{
		return {x + other.x,
				y + other.y};
	}
};

struct lab
{
	uint16_t l;
	uint16_t a;
	uint16_t b;

	lab operator+=(const lab &other)
	{
		l += other.l;
		a += other.a;
		b += other.b;

		return *this;
	}
};

static volatile sig_atomic_t running = true;
static void sigint_handler_running(int signum)
{
	(void)signum;
	running = false;
}

static int get_index(xy pos, int width)
{
	return pos.x + pos.y * width;
}

static lab get_pixel(const std::vector<uint16_t> &pixels, xy pos, int width)
{
	int i = get_index(pos, width) * 4;

	uint16_t l = pixels[i + 0];
	uint16_t a = pixels[i + 1];
	uint16_t b = pixels[i + 2];

	return {l, a, b};
}

static void set_pixel(std::vector<uint16_t> &pixels, xy pos, int width, lab lab)
{
	int i = get_index(pos, width) * 4;

	pixels[i + 0] = lab.l;
	pixels[i + 1] = lab.a;
	pixels[i + 2] = lab.b;
}

static void update_neighbors(std::vector<uint64_t> &neighbor_totals, xy center, lab old_pixel, lab new_pixel, int width, int height, int kernel_radius)
{
	// TODO: By padding the input image it should be possible to get rid of these bounds variables
	int dy_min = -std::min(center.y, kernel_radius);
	int dy_max = std::min(height - 1 - center.y, kernel_radius);

	int dx_min = -std::min(center.x, kernel_radius);
	int dx_max = std::min(width - 1 - center.x, kernel_radius);

	for (int dy = dy_min; dy <= dy_max; dy++)
	{
		for (int dx = dx_min; dx <= dx_max; dx++)
		{
			xy neighbor = {center.x + dx, center.y + dy};

			assert(neighbor_totals[get_index(neighbor, width) * 4 + 0] >= old_pixel.l);
			assert(neighbor_totals[get_index(neighbor, width) * 4 + 1] >= old_pixel.a);
			assert(neighbor_totals[get_index(neighbor, width) * 4 + 2] >= old_pixel.b);

			// Replace an old pixel with a new pixel in neighbor_totals
			neighbor_totals[get_index(neighbor, width) * 4 + 0] += -old_pixel.l + new_pixel.l;
			neighbor_totals[get_index(neighbor, width) * 4 + 1] += -old_pixel.a + new_pixel.a;
			neighbor_totals[get_index(neighbor, width) * 4 + 2] += -old_pixel.b + new_pixel.b;
		}
	}
}

static double get_color_difference(lab pixel, lab neighbor_pixel)
{
	double l_diff = pixel.l - neighbor_pixel.l;
	double a_diff = pixel.a - neighbor_pixel.a;
	double b_diff = pixel.b - neighbor_pixel.b;

	return (l_diff * l_diff +
			a_diff * a_diff +
			b_diff * b_diff);
}

static lab get_neighbor_average(const std::vector<uint64_t> &neighbor_totals, const std::vector<float> &neighbor_counts, xy pos, int width)
{
	int i = get_index(pos, width) * 4;

	uint64_t l = neighbor_totals[i + 0];
	uint64_t a = neighbor_totals[i + 1];
	uint64_t b = neighbor_totals[i + 2];

	float c = neighbor_counts[get_index(pos, width)];

	// TODO: Profile whether it's worth it to cache this division result in a new vector
	return {static_cast<uint16_t>(l / c),
			static_cast<uint16_t>(a / c),
			static_cast<uint16_t>(b / c)};
}

static bool should_swap(const std::vector<uint64_t> &neighbor_totals, const std::vector<float> &neighbor_counts, lab pixel1, lab pixel2, xy pos1, xy pos2, int width)
{
	lab i1_neighbor_average = get_neighbor_average(neighbor_totals, neighbor_counts, pos1, width);
	double i1_old_score = get_color_difference(pixel1, i1_neighbor_average);
	double i1_new_score = get_color_difference(pixel2, i1_neighbor_average);
	double i1_score_difference = -i1_old_score + i1_new_score;

	lab i2_neighbor_average = get_neighbor_average(neighbor_totals, neighbor_counts, pos2, width);
	double i2_old_score = get_color_difference(pixel2, i2_neighbor_average);
	double i2_new_score = get_color_difference(pixel1, i2_neighbor_average);
	double i2_score_difference = -i2_old_score + i2_new_score;

	double score_difference = i1_score_difference + i2_score_difference;

	return score_difference < 0;
}

static xy get_pos(int i, int width)
{
	return {i % width, i / width};
}

#ifndef NDEBUG
static std::vector<uint64_t> get_neighbor_totals_slow_reference(const std::vector<uint16_t> &pixels, int width, int height, int kernel_radius)
{
	std::vector<uint64_t> neighbor_totals(pixels.size(), 0);

	// For every pixel
	for (int py = 0; py < height; py++)
	{
		for (int px = 0; px < width; px++)
		{
			// TODO: By padding the input image it should be possible to get rid of these bounds variables
			int kdy_min = -std::min(py, kernel_radius);
			int kdy_max = std::min(height - 1 - py, kernel_radius);

			int kdx_min = -std::min(px, kernel_radius);
			int kdx_max = std::min(width - 1 - px, kernel_radius);

			// TODO:: Replace this with a little one-line calculus
			// Apply the kernel
			for (int kdy = kdy_min; kdy <= kdy_max; kdy++)
			{
				for (int kdx = kdx_min; kdx <= kdx_max; kdx++)
				{
					int x = px + kdx;
					int y = py + kdy;

					uint16_t l = pixels[(x + y * width) * 4 + 0];
					uint16_t a = pixels[(x + y * width) * 4 + 1];
					uint16_t b = pixels[(x + y * width) * 4 + 2];

					neighbor_totals[(px + py * width) * 4 + 0] += l;
					neighbor_totals[(px + py * width) * 4 + 1] += a;
					neighbor_totals[(px + py * width) * 4 + 2] += b;
				}
			}
		}
	}

	return neighbor_totals;
}
#endif

static void vertical_pass(std::vector<uint64_t> &neighbor_totals, std::vector<uint64_t> &neighbor_totals_copy, int width, int height, int kernel_radius)
{
	for (int px = 0; px < width; px++)
	{
		int pxi = px * 4;

		uint64_t neighbor_total_l = 0;
		uint64_t neighbor_total_a = 0;
		uint64_t neighbor_total_b = 0;

		// Give the topmost pixel its final neighbor total
		for (int kdy = 0; kdy <= std::min(kernel_radius, height - 1); kdy++)
		{
			assert(kdy < height);

			int pi = pxi + kdy * width * 4;

			neighbor_total_l += neighbor_totals_copy[pi + 0];
			neighbor_total_a += neighbor_totals_copy[pi + 1];
			neighbor_total_b += neighbor_totals_copy[pi + 2];
		}
		neighbor_totals[pxi + 0] = neighbor_total_l;
		neighbor_totals[pxi + 1] = neighbor_total_a;
		neighbor_totals[pxi + 2] = neighbor_total_b;

		// Give the rest of the top edge pixels their final neighbor total
		for (int py = 1 + kernel_radius; py <= std::min(kernel_radius * 2, height - 1); py++)
		{
			assert(py < height);

			int pi_added = pxi + py * width * 4;
			neighbor_total_l += neighbor_totals_copy[pi_added + 0];
			neighbor_total_a += neighbor_totals_copy[pi_added + 1];
			neighbor_total_b += neighbor_totals_copy[pi_added + 2];

			int pi = pxi + (py - kernel_radius) * width * 4;
			neighbor_totals[pi + 0] = neighbor_total_l;
			neighbor_totals[pi + 1] = neighbor_total_a;
			neighbor_totals[pi + 2] = neighbor_total_b;
		}

		if (kernel_radius + 1 < height - kernel_radius)
		{
			// Give the center pixels (they are the majority) their final neighbor total
			for (int py = kernel_radius + 1; py < height - kernel_radius; py++)
			{
				assert(py < height);

				int pi_subtracted = pxi + (py - kernel_radius - 1) * width * 4;
				neighbor_total_l -= neighbor_totals_copy[pi_subtracted + 0];
				neighbor_total_a -= neighbor_totals_copy[pi_subtracted + 1];
				neighbor_total_b -= neighbor_totals_copy[pi_subtracted + 2];

				int pi_added = pxi + (py + kernel_radius) * width * 4;
				neighbor_total_l += neighbor_totals_copy[pi_added + 0];
				neighbor_total_a += neighbor_totals_copy[pi_added + 1];
				neighbor_total_b += neighbor_totals_copy[pi_added + 2];

				int pi = pxi + py * width * 4;
				neighbor_totals[pi + 0] = neighbor_total_l;
				neighbor_totals[pi + 1] = neighbor_total_a;
				neighbor_totals[pi + 2] = neighbor_total_b;
			}
		}
		else
		{
			// Give the center pixels the earlier neighbor total, if the kernel_radius is huge
			for (int py = std::max(height - kernel_radius, 1); py <= std::min(kernel_radius, height - 1); py++)
			{
				assert(py >= 0);
				assert(py < height);

				int pi = pxi + py * width * 4;
				neighbor_totals[pi + 0] = neighbor_total_l;
				neighbor_totals[pi + 1] = neighbor_total_a;
				neighbor_totals[pi + 2] = neighbor_total_b;
			}
		}

		// Give the rest of the bottom edge pixels their final neighbor total
		for (int py = std::max(height - kernel_radius, kernel_radius + 1); py < height; py++)
		{
			assert(py >= 0);
			assert(py < height);

			int pi_subtracted = pxi + (py - kernel_radius - 1) * width * 4;
			neighbor_total_l -= neighbor_totals_copy[pi_subtracted + 0];
			neighbor_total_a -= neighbor_totals_copy[pi_subtracted + 1];
			neighbor_total_b -= neighbor_totals_copy[pi_subtracted + 2];

			int pi = pxi + py * width * 4;
			neighbor_totals[pi + 0] = neighbor_total_l;
			neighbor_totals[pi + 1] = neighbor_total_a;
			neighbor_totals[pi + 2] = neighbor_total_b;
		}
	}
}

static void horizontal_pass(std::vector<uint64_t> &neighbor_totals, const std::vector<uint16_t> &pixels, int width, int height, int kernel_radius)
{
	for (int py = 0; py < height; py++)
	{
		int pyi = py * width * 4;

		uint64_t neighbor_total_l = 0;
		uint64_t neighbor_total_a = 0;
		uint64_t neighbor_total_b = 0;

		// Give the leftmost pixel its final neighbor total
		// Given a width of 10 and kernel_radius of 2, this adds [0, 2] and writes [0]
		// Given a width of 10 and kernel_radius of 5, this adds [0, 5] and writes [0]
		// Given a width of 10 and kernel_radius of 6, this adds [0, 6] and writes [0]
		// Given a width of 10 and kernel_radius of 7, this adds [0, 7] and writes [0]
		// Given a width of 10 and kernel_radius of 8, this adds [0, 8] and writes [0]
		// Given a width of 10 and kernel_radius of 9, this adds [0, 9] and writes [0]
		// Given a width of 10 and kernel_radius of 10, this adds [0, 9] and writes [0]
		for (int kdx = 0; kdx <= std::min(kernel_radius, width - 1); kdx++)
		{
			assert(kdx < width);

			int pi = kdx * 4 + pyi;

			neighbor_total_l += pixels[pi + 0];
			neighbor_total_a += pixels[pi + 1];
			neighbor_total_b += pixels[pi + 2];
		}
		neighbor_totals[pyi + 0] = neighbor_total_l;
		neighbor_totals[pyi + 1] = neighbor_total_a;
		neighbor_totals[pyi + 2] = neighbor_total_b;

		// Give the rest of the left edge pixels their final neighbor total
		// Given a width of 10 and kernel_radius of 2, this adds [3, 4] and writes [1, 2]
		// Given a width of 10 and kernel_radius of 5, this adds [6, 9] and writes [1, 4]
		// Given a width of 10 and kernel_radius of 6, this adds [7, 9] and writes [1, 3]
		// Given a width of 10 and kernel_radius of 7, this adds [8, 9] and writes [1, 2]
		// Given a width of 10 and kernel_radius of 8, this adds [9] and writes [1]
		// Given a width of 10 and kernel_radius of 9, this does nothing
		for (int px = 1 + kernel_radius; px <= std::min(kernel_radius * 2, width - 1); px++)
		{
			assert(px < width);

			int pi_added = px * 4 + pyi;
			neighbor_total_l += pixels[pi_added + 0];
			neighbor_total_a += pixels[pi_added + 1];
			neighbor_total_b += pixels[pi_added + 2];

			int pi = (px - kernel_radius) * 4 + pyi;
			neighbor_totals[pi + 0] = neighbor_total_l;
			neighbor_totals[pi + 1] = neighbor_total_a;
			neighbor_totals[pi + 2] = neighbor_total_b;
		}

		if (kernel_radius + 1 < width - kernel_radius)
		{
			// Give the center pixels (they are the majority) their final neighbor total
			// Given a width of 10 and kernel_radius of 2, this subtracts [0, 4] and adds [5, 9] and writes [3, 7]
			// Given a width of 10 and kernel_radius of 3, this subtracts [0, 2] and adds [7, 9] and writes [4, 6]
			// Given a width of 10 and kernel_radius of 4, this subtracts [0] and adds [9] and writes [5]
			// Given a width of 10 and kernel_radius of 5, this does nothing
			for (int px = kernel_radius + 1; px < width - kernel_radius; px++)
			{
				assert(px < width);

				int pi_subtracted = (px - kernel_radius - 1) * 4 + pyi;
				neighbor_total_l -= pixels[pi_subtracted + 0];
				neighbor_total_a -= pixels[pi_subtracted + 1];
				neighbor_total_b -= pixels[pi_subtracted + 2];

				int pi_added = (px + kernel_radius) * 4 + pyi;
				neighbor_total_l += pixels[pi_added + 0];
				neighbor_total_a += pixels[pi_added + 1];
				neighbor_total_b += pixels[pi_added + 2];

				int pi = px * 4 + pyi;
				neighbor_totals[pi + 0] = neighbor_total_l;
				neighbor_totals[pi + 1] = neighbor_total_a;
				neighbor_totals[pi + 2] = neighbor_total_b;
			}
		}
		else
		{
			// Give the center pixels the earlier neighbor total, if the kernel_radius is huge
			// Given a width of 10 and kernel_radius of 5, this writes [5]
			// Given a width of 10 and kernel_radius of 6, this writes [4, 6]
			// Given a width of 10 and kernel_radius of 7, this writes [3, 7]
			// Given a width of 10 and kernel_radius of 8, this writes [2, 8]
			// Given a width of 10 and kernel_radius of 9, this writes [1, 9]
			// Given a width of 10 and kernel_radius of 10, this writes [1, 9]
			for (int px = std::max(width - kernel_radius, 1); px <= std::min(kernel_radius, width - 1); px++)
			{
				assert(px >= 0);
				assert(px < width);

				int pi = px * 4 + pyi;
				neighbor_totals[pi + 0] = neighbor_total_l;
				neighbor_totals[pi + 1] = neighbor_total_a;
				neighbor_totals[pi + 2] = neighbor_total_b;
			}
		}

		// Give the rest of the right edge pixels their final neighbor total
		// Given a width of 10 and kernel_radius of 2, this subtracts [5, 6] and writes [8, 9]
		// Given a width of 10 and kernel_radius of 5, this subtracts [0, 3] and writes [6, 9]
		// Given a width of 10 and kernel_radius of 6, this subtracts [0, 2] and writes [7, 9]
		// Given a width of 10 and kernel_radius of 7, this subtracts [0, 1] and writes [8, 9]
		// Given a width of 10 and kernel_radius of 8, this subtracts [0] and writes [9]
		// Given a width of 10 and kernel_radius of 9, this does nothing
		for (int px = std::max(width - kernel_radius, kernel_radius + 1); px < width; px++)
		{
			assert(px >= 0);
			assert(px < width);

			int pi_subtracted = (px - kernel_radius - 1) * 4 + pyi;
			neighbor_total_l -= pixels[pi_subtracted + 0];
			neighbor_total_a -= pixels[pi_subtracted + 1];
			neighbor_total_b -= pixels[pi_subtracted + 2];

			int pi = px * 4 + pyi;
			neighbor_totals[pi + 0] = neighbor_total_l;
			neighbor_totals[pi + 1] = neighbor_total_a;
			neighbor_totals[pi + 2] = neighbor_total_b;
		}
	}
}

// This is a convolution function; see this example, where kernel_radius is 1:
// (x=0, y=0) aka 1 is the center, and the neighbor total is 1+2+4+5:
// [1 2] 3
// [4 5] 6
// (x=1, y=0) aka 2 is the center, and the neighbor total is 1+2+3+4+5+6:
// [1 2 3]
// [4 5 6]
// (x=2, y=0) aka 3 is the center, and the neighbor total is 2+3+5+6:
// 1 [2 3]
// 4 [5 6]
static void get_neighbor_totals(std::vector<uint64_t> &neighbor_totals, std::vector<uint64_t> &neighbor_totals_copy, const std::vector<uint16_t> &pixels, int width, int height, int kernel_radius)
{
	std::fill(neighbor_totals.begin(), neighbor_totals.end(), 0);

	horizontal_pass(neighbor_totals, pixels, width, height, kernel_radius);

	// This is used in vertical_pass for subtracting old neighbor_totals that have shifted out of the kernel's radius
	// TODO: Check using the assembly whether this isn't doing useless bounds/resize checks
	neighbor_totals_copy = neighbor_totals;

	vertical_pass(neighbor_totals, neighbor_totals_copy, width, height, kernel_radius);
}

static void sort_minority(std::vector<uint16_t> &pixels, std::vector<uint64_t> &neighbor_totals, const std::vector<float> &neighbor_counts, const std::vector<int> &normal_to_opaque_index_lut, int width, int height, int pair_count, int kernel_radius, uint64_t &swaps, uint64_t &attempted_swaps, std::uniform_int_distribution<std::mt19937::result_type> &get_rand, std::mt19937 &rng, bool transparent)
{
	// TODO: Use a C++ parallel-loop here, to get it closer to sort.cl
	for (int i = 0; i < pair_count; i += 2)
	{
		int rand_i1 = get_rand(rng);
		int rand_i2 = get_rand(rng);

		if (transparent)
		{
			rand_i1 = normal_to_opaque_index_lut[rand_i1];
			rand_i2 = normal_to_opaque_index_lut[rand_i2];
		}

		xy pos1 = get_pos(rand_i1, width);
		xy pos2 = get_pos(rand_i2, width);

		lab pixel1 = get_pixel(pixels, pos1, width);
		lab pixel2 = get_pixel(pixels, pos2, width);

		if (should_swap(neighbor_totals, neighbor_counts, pixel1, pixel2, pos1, pos2, width))
		{
			set_pixel(pixels, pos1, width, pixel2);
			update_neighbors(neighbor_totals, pos1, pixel1, pixel2, width, height, kernel_radius);

			set_pixel(pixels, pos2, width, pixel1);
			update_neighbors(neighbor_totals, pos2, pixel2, pixel1, width, height, kernel_radius);

			swaps++;
		}

		attempted_swaps++;
	}
}

static void sort_majority(std::vector<uint16_t> &pixels, std::vector<uint64_t> &neighbor_totals, const std::vector<float> &neighbor_counts, const std::vector<int> &normal_to_opaque_index_lut, int width, int pair_count, uint64_t &swaps, uint64_t &attempted_swaps, std::uniform_int_distribution<std::mt19937::result_type> &get_rand, std::mt19937 &rng, bool transparent)
{
	// TODO: Use a C++ parallel-loop here, to get it closer to sort.cl
	for (int i = 0; i < pair_count; i += 2)
	{
		int rand_i1 = get_rand(rng);
		int rand_i2 = get_rand(rng);

		if (transparent)
		{
			rand_i1 = normal_to_opaque_index_lut[rand_i1];
			rand_i2 = normal_to_opaque_index_lut[rand_i2];
		}

		xy pos1 = get_pos(rand_i1, width);
		xy pos2 = get_pos(rand_i2, width);

		lab pixel1 = get_pixel(pixels, pos1, width);
		lab pixel2 = get_pixel(pixels, pos2, width);

		if (should_swap(neighbor_totals, neighbor_counts, pixel1, pixel2, pos1, pos2, width))
		{
			set_pixel(pixels, pos1, width, pixel2);
			set_pixel(pixels, pos2, width, pixel1);
			swaps++;
		}

		attempted_swaps++;
	}
}

static std::string humanize_number(double n)
{
	std::ostringstream ss;
	ss << std::fixed << std::setprecision(1);

	if (n > -1'000 && n < 1'000)
	{
		ss << n;
		return ss.str();
	}
	else if (n > -1'000'000 && n < 1'000'000)
	{
		double d = n / 1'000.0;
		ss << d;
		return ss.str() + " thousand";
	}
	else if (n > -1'000'000'000 && n < 1'000'000'000)
	{
		double d = n / 1'000'000.0;
		ss << d;
		return ss.str() + " million";
	}

	double d = n / 1'000'000'000.0;
	ss << d;
	return ss.str() + " billion";
}

static std::string humanize_seconds(double double_seconds)
{
	uint64_t uint64_seconds = double_seconds;

	std::string returned;

	if (uint64_seconds >= 60 * 60)
	{
		uint64_t hours = uint64_seconds / 60 / 60;
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(0);
		ss << hours;
		returned += ss.str() + " hour" + (hours == 1 ? "" : "s") + " and ";
	}

	if (uint64_seconds >= 60)
	{
		uint64_t minutes = (uint64_seconds / 60) % 60;
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(0);
		ss << minutes;
		returned += ss.str() + " minute" + (minutes == 1 ? "" : "s") + " and ";
	}

	double_seconds = std::fmod(double_seconds, 60);
	std::ostringstream ss;
	ss << std::fixed << std::setprecision(1);
	ss << double_seconds;
	returned += ss.str() + " second" + (double_seconds == 1 ? "" : "s");

	return returned;
}

static void print_status(int saved_results, std::chrono::steady_clock::time_point &prev_now, uint64_t loops, uint64_t swaps, uint64_t prev_swaps, uint64_t attempted_swaps, uint64_t prev_attempted_swaps, double &prev_attempted_swaps_per_second, double &prev_attempted_swaps_per_swap, const std::chrono::steady_clock::time_point &start_time)
{
	const auto now = std::chrono::steady_clock::now();
	const double seconds = std::chrono::duration<double>(now - start_time).count();

	double attempted_swaps_per_second = attempted_swaps / seconds;
	double attempted_swaps_per_swap = attempted_swaps / static_cast<double>(swaps);

	std::cout
		<< "Frame " << saved_results
		<< ", " << humanize_seconds(seconds)
		<< " (+" << humanize_seconds(std::chrono::duration<double>(now - prev_now).count()) << ")"
		<< ", " << humanize_number(loops) << " loops"
		<< ", " << humanize_number(swaps) << " swaps"
		<< " (+" << humanize_number(swaps - prev_swaps) << ")"
		<< ", " << humanize_number(attempted_swaps) << " attempted swaps"
		<< " (+" << humanize_number(attempted_swaps - prev_attempted_swaps) << ")"
		<< ", " << humanize_number(attempted_swaps_per_second) << " attempted swaps/second"
		<< " (+" << humanize_number(attempted_swaps_per_second - prev_attempted_swaps_per_second) << ")"
		<< ", " << humanize_number(attempted_swaps_per_swap) << " attempted swaps/swap"
		<< " (+" << humanize_number(attempted_swaps_per_swap - prev_attempted_swaps_per_swap) << ")"
		<< std::endl;

	prev_now = now;
	prev_attempted_swaps_per_second = attempted_swaps_per_second;
	prev_attempted_swaps_per_swap = attempted_swaps_per_swap;
}

static void save_result(const std::vector<uint16_t> &pixels, const std::vector<size_t> &shape, const std::filesystem::path &output_npy_path)
{
	cnpy::npy_save(output_npy_path, pixels.data(), shape, "w");
}

static std::filesystem::path get_output_npy_path(
	const std::filesystem::path &output_npy_path,
	bool no_overwriting_output,
	int saved_image_leading_zero_count,
	int saved_results)
{
	if (no_overwriting_output)
	{
		// Create the string "_0000", assuming saved_results is 0 and saved_image_leading_zero_count is 4
		std::ostringstream ss;
		ss << std::setw(saved_image_leading_zero_count) << std::setfill('0') << saved_results;
		std::string saved_results_str(ss.str());

		// Append "_0000" to the output filename's stem
		std::filesystem::path saved_filename(output_npy_path.stem().string() + "_" + saved_results_str + output_npy_path.extension().string());

		// Stitch the parent directory path back to the front
		return output_npy_path.parent_path() / saved_filename;
	}
	else
	{
		return output_npy_path;
	}
}

static void try_save(std::chrono::steady_clock::time_point &last_saved_time, const Args &args, int &saved_results, const std::vector<uint16_t> &pixels, const std::vector<size_t> &shape)
{
	const auto now = std::chrono::steady_clock::now();

	if (now > last_saved_time + std::chrono::seconds(args.seconds_between_saves))
	{
		const std::filesystem::path output_npy_path = get_output_npy_path(
			args.output_npy_path,
			args.no_overwriting_output,
			args.saved_image_leading_zero_count,
			saved_results);

		save_result(pixels, shape, output_npy_path);
		saved_results++;

		last_saved_time = std::chrono::steady_clock::now();
	}
}

static void try_print(std::chrono::steady_clock::time_point &last_printed_time, int seconds_between_prints, int &saved_results, std::chrono::steady_clock::time_point &prev_now, uint64_t &loops, uint64_t &swaps, uint64_t &prev_swaps, uint64_t &attempted_swaps, uint64_t &prev_attempted_swaps, double &prev_attempted_swaps_per_second, double &prev_attempted_swaps_per_swap, const std::chrono::steady_clock::time_point &start_time)
{
	const auto now = std::chrono::steady_clock::now();

	if (now > last_printed_time + std::chrono::seconds(seconds_between_prints))
	{
		print_status(saved_results, prev_now, loops, swaps, prev_swaps, attempted_swaps, prev_attempted_swaps, prev_attempted_swaps_per_second, prev_attempted_swaps_per_swap, start_time);

		prev_swaps = swaps;
		prev_attempted_swaps = attempted_swaps;

		last_printed_time = std::chrono::steady_clock::now();
	}
}

static std::vector<int> get_normal_to_opaque_index_lut(const std::vector<uint16_t> &pixels, int pixels_size)
{
	std::vector<int> normal_to_opaque_index_lut;

	int offset = 0;
	for (int i = 3; i < pixels_size; i += 4)
	{
		uint16_t alpha = pixels[i];

		// TODO: Check that this produces the same result as sort.py's version of this code
		if (alpha != 0)
		{
			normal_to_opaque_index_lut.push_back(offset);
		}

		offset++;
	}

	return normal_to_opaque_index_lut;
}

// TODO: Profile whether it's faster to just recalculate this on the fly, rather than looking in a vector that can cause a cache miss
// Returns a vector of floats instead of ints,
// since these values will be used for float division
static std::vector<float> get_neighbor_counts(int kernel_radius, int width, int height)
{
	std::vector<float> neighbor_counts(width * height, 0);

	for (int py = 0; py < height; py++)
	{
		for (int px = 0; px < width; px++)
		{
			int kernel_x_count = std::min(px, kernel_radius) + std::min(width - 1 - px, kernel_radius) + 1;
			int kernel_y_count = std::min(py, kernel_radius) + std::min(height - 1 - py, kernel_radius) + 1;

			neighbor_counts[px + py * width] += kernel_x_count * kernel_y_count;
		}
	}

	return neighbor_counts;
}

static int get_opaque_pixel_count(const std::vector<uint16_t> &pixels, int pixels_size)
{
	int opaque_pixel_count = 0;
	for (int i = 3; i < pixels_size; i += 4)
	{
		if (pixels[i] != 0)
		{
			opaque_pixel_count++;
		}
	}

	// TODO: Get rid of this limitation by introducing x and y start offsets,
	// and alternating them
	if (opaque_pixel_count % 2 != 0)
	{
		std::cerr << "The program currently doesn't support images with an odd number of pixels" << std::endl;
		exit(EXIT_FAILURE);
	}

	return opaque_pixel_count;
}

int main(int argc, char *argv[])
{
	Args args(argc, argv);

	std::cout << "Reading input_npy_path" << std::endl;
	cnpy::NpyArray arr = cnpy::npy_load(args.input_npy_path);
	// This won't ever turn into a dangling pointer, since the vector stays a constant size
	std::vector<uint16_t> pixels = arr.as_vec<uint16_t>();

	int height = arr.shape[0];
	int width = arr.shape[1];

	int kernel_radius = args.kernel_radius;
	// Clamp the kernel radius so it isn't uselessly larger than the width and height
	int max_kernel_radius = std::max(width, height) - 1;
	kernel_radius = std::min(kernel_radius, max_kernel_radius);

	int pixels_size = pixels.size();
	int opaque_pixel_count = get_opaque_pixel_count(pixels, pixels_size);
	int pair_count = opaque_pixel_count / 2;
	bool transparent = pixels_size / 4 != opaque_pixel_count;

	std::cout << "Calculating neighbor_totals" << std::endl;
	std::vector<uint64_t> neighbor_totals(pixels.size());
	std::vector<uint64_t> neighbor_totals_copy(neighbor_totals);

	get_neighbor_totals(neighbor_totals, neighbor_totals_copy, pixels, width, height, kernel_radius);
#ifndef NDEBUG
	assert(neighbor_totals == get_neighbor_totals_slow_reference(pixels, width, height, kernel_radius));
#endif

	std::cout << "Calculating neighbor_counts" << std::endl;
	const std::vector<float> neighbor_counts = get_neighbor_counts(kernel_radius, width, height);

	uint64_t swaps = 0;
	uint64_t prev_swaps = 0;

	uint64_t attempted_swaps = 0;
	uint64_t prev_attempted_swaps = 0;

	int saved_results = 0;

	std::cout << "Calculating normal_to_opaque_index_lut" << std::endl;
	std::vector<int> normal_to_opaque_index_lut = get_normal_to_opaque_index_lut(pixels, pixels_size);

	const std::filesystem::path output_npy_path = get_output_npy_path(
		args.output_npy_path,
		args.no_overwriting_output,
		args.saved_image_leading_zero_count,
		saved_results);

	if (signal(SIGINT, sigint_handler_running) == SIG_ERR)
	{
		abort();
	}

	uint64_t loops = 0;

	bool majority = true;

	double prev_attempted_swaps_per_second = 0;
	double prev_attempted_swaps_per_swap = 0;

	// A seed for the random number generator
	std::random_device rd;
	// mersenne_twister_engine seeded with rd()
	// TODO: Profile whether a faster RNG function should be used
	std::mt19937 rng(rd());
	// Range [0, opaque_pixel_count)
	std::uniform_int_distribution<std::mt19937::result_type> get_rand(0, opaque_pixel_count - 1);

	std::cout << "\nRunning sort_majority()" << std::endl;

	const auto start_time = std::chrono::steady_clock::now();
	auto prev_now = start_time;
	auto last_printed_time = start_time;
	auto last_saved_time = start_time;

	while (running && majority)
	{
		loops++;

		try_print(last_printed_time, args.seconds_between_prints, saved_results, prev_now, loops, swaps, prev_swaps, attempted_swaps, prev_attempted_swaps, prev_attempted_swaps_per_second, prev_attempted_swaps_per_swap, start_time);
		try_save(last_saved_time, args, saved_results, pixels, arr.shape);

		sort_majority(pixels, neighbor_totals, neighbor_counts, normal_to_opaque_index_lut, width, pair_count, swaps, attempted_swaps, get_rand, rng, transparent);

		get_neighbor_totals(neighbor_totals, neighbor_totals_copy, pixels, width, height, kernel_radius);
#ifndef NDEBUG
		assert(neighbor_totals == get_neighbor_totals_slow_reference(pixels, width, height, kernel_radius));
#endif

		// TODO: Profile whether this casting is slow
		if (attempted_swaps / static_cast<double>(swaps) > args.sort_minority_threshold)
		{
			majority = false;
		}
	}

	if (!majority)
	{
		std::cout << "\nRunning sort_minority()" << std::endl;
	}

	while (running)
	{
		loops++;

		try_print(last_printed_time, args.seconds_between_prints, saved_results, prev_now, loops, swaps, prev_swaps, attempted_swaps, prev_attempted_swaps, prev_attempted_swaps_per_second, prev_attempted_swaps_per_swap, start_time);
		try_save(last_saved_time, args, saved_results, pixels, arr.shape);

		sort_minority(pixels, neighbor_totals, neighbor_counts, normal_to_opaque_index_lut, width, height, pair_count, kernel_radius, swaps, attempted_swaps, get_rand, rng, transparent);
	}

	save_result(pixels, arr.shape, output_npy_path);
	saved_results++;

	print_status(saved_results, prev_now, loops, swaps, prev_swaps, attempted_swaps, prev_attempted_swaps, prev_attempted_swaps_per_second, prev_attempted_swaps_per_swap, start_time);

	std::cout << "Gootbye" << std::endl;

	return EXIT_SUCCESS;
}
