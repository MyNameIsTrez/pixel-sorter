#include "cnpy.h"

#include <filesystem>
#include <getopt.h>
#include <iomanip>
#include <signal.h>

static volatile sig_atomic_t running = true;

static void sigint_handler_running(int signum)
{
	(void)signum;
	running = false;
}

class Args
{
public:
	Args(int argc, char *argv[])
		: seconds_between_saves(1)
		, kernel_radius(100)
		, no_overwriting_output(false)
		, saved_image_leading_zero_count(4)
		, input_npy_path()
		, output_npy_path()
	{
		int c;

		char *program_name = argv[0];

		while (1)
		{
			int option_index = 0;
			static option long_options[] = {
				{"help", no_argument, 0, 'h'},
				{"seconds-between-saves", required_argument, 0, 's'},
				{"kernel-radius", required_argument, 0, 'k'},
				{"no-overwriting-output", no_argument, 0, 'n'},
				{"saved-image-leading-zero-count", required_argument, 0, 'z'},
				{0, 0, 0, 0}};

			c = getopt_long(argc, argv, "hi:s:k:nz:w:", long_options, &option_index);

			// Detect the end of the options
			if (c == -1)
			{
				break;
			}

			switch (c)
			{
			case 'h':
				print_help(program_name);
				exit(EXIT_FAILURE);

			case 's':
				seconds_between_saves = std::stoi(optarg);
				std::cout << "Set seconds_between_saves to " << seconds_between_saves << std::endl;
				break;

			case 'k':
				kernel_radius = std::stoi(optarg);
				std::cout << "Set kernel_radius to " << kernel_radius << std::endl;
				break;

			case 'n':
				no_overwriting_output = true;
				std::cout << "Set no_overwriting_output to " << no_overwriting_output << std::endl;
				break;

			case 'z':
				saved_image_leading_zero_count = std::stoi(optarg);
				std::cout << "Set saved_image_leading_zero_count to " << saved_image_leading_zero_count << std::endl;
				break;

			case '?':
				// getopt_long() already printed an error message
				exit(EXIT_FAILURE);

			default:
				abort();
			}
		}

		// If not exactly two positional arguments were provided
		if (optind != argc - 2)
		{
			print_help(program_name);
			exit(EXIT_FAILURE);
		}

		input_npy_path = argv[argc - 2];
		output_npy_path = argv[argc - 1];
	}

	int seconds_between_saves;
	int kernel_radius;
	bool no_overwriting_output;
	int saved_image_leading_zero_count;
	std::filesystem::path input_npy_path;
	std::filesystem::path output_npy_path;

private:
	void print_help(char *program_name)
	{
		std::cerr
			<< "Usage: " << program_name << " input_npy_path output_npy_path [-h] [-s SECONDS_BETWEEN_SAVES] [-k KERNEL_RADIUS] [-n] [-z SAVED_IMAGE_LEADING_ZERO_COUNT]\n\n";

		std::cerr
			<< "positional arguments:\n"
			"  input_npy_path        Input npy file path, generated by for example rgb2lab.py\n"
			"  output_npy_path       Output npy file path, which can then be used by for example lab2rgb.py\n\n";

		std::cerr
			<< "options:\n"
			"  -h, --help            show this help message and exit\n"
			"  -s SECONDS_BETWEEN_SAVES, --seconds-between-saves SECONDS_BETWEEN_SAVES\n"
			"                        How often the current output image gets saved (default: 1)\n"
			"  -k KERNEL_RADIUS, --kernel-radius KERNEL_RADIUS\n"
			"                        The radius of neighbors that get compared against the current pixel's color; a higher radius means better sorting, but is quadratically slower (default: 100)\n"
			"  -n, --no-overwriting-output\n"
			"                        Save all output images, instead of the default behavior of overwriting (default: False)\n"
			"  -z SAVED_IMAGE_LEADING_ZERO_COUNT, --saved-image-leading-zero-count SAVED_IMAGE_LEADING_ZERO_COUNT\n"
			"                        The number of leading zeros on saved images; this has no effect if the -n switch isn't passed! (default: 4)\n";
	}
};

void print_status(int saved_results, uint64_t prev_attemped_swaps, uint64_t attempted_swaps, const std::chrono::steady_clock::time_point &start_time)
{
	const auto now = std::chrono::steady_clock::now();
	const auto seconds = std::chrono::duration_cast<std::chrono::seconds>(now - start_time).count();

	std::cout
		<< "Frame " << saved_results
		<< ", " << seconds << " seconds"
		<< ", " << attempted_swaps << " attempted swaps"
		<< " (+" << attempted_swaps - prev_attemped_swaps << ")"
		<< std::endl;
}

void save_result(float *pixels, const std::vector<size_t> &shape, const std::filesystem::path &output_npy_path)
{
	cnpy::npy_save(output_npy_path, pixels, shape, "w");
}

std::filesystem::path get_output_npy_path(
		const std::filesystem::path &output_npy_path,
		bool no_overwriting_output,
		int saved_image_leading_zero_count,
		int saved_results)
{
    if (no_overwriting_output)
	{
		// Create the string "_0000", assuming saved_results is 0 and saved_image_leading_zero_count is 4
		std::ostringstream ss;
		ss << std::setw(saved_image_leading_zero_count) << std::setfill('0') << saved_results;
		std::string saved_results_str(ss.str());

		// Append "_0000" to the output filename's stem
		std::filesystem::path saved_filename(output_npy_path.stem().string() + "_" + saved_results_str + output_npy_path.extension().string());

		// Stitch the parent directory path back to the front
		return output_npy_path.parent_path() / saved_filename;
	}
    else
	{
        return output_npy_path;
	}
}

// c++ -Wall -Wextra -Werror -Wpedantic -Wfatal-errors -fsanitize=address,undefined -g -std=c++17 main.cpp cnpy.cpp -lz -o a.out && ./a.out "../input_npy/heart.npy" "../output_npy/heart.npy"
// ./a.out "../input_npy/heart.npy" "../output_npy/heart.npy"
int main(int argc, char *argv[])
{
	const auto start_time = std::chrono::steady_clock::now();

	std::cout << "Started program" << std::endl;

	Args args(argc, argv);

	// TODO: Use these
	(void)args.seconds_between_saves;
	(void)args.kernel_radius;
	(void)args.no_overwriting_output;
	(void)args.saved_image_leading_zero_count;
	(void)args.input_npy_path;
	(void)args.output_npy_path;

	// TODO: Use this so "_0000" can just be appended to .stem
	cnpy::NpyArray arr = cnpy::npy_load(args.input_npy_path);
	// TODO: Won't this create a dangling pointer or smth?
	float *pixels = arr.data<float>();

	// size_t width = arr.shape.at(0);
	// size_t height = arr.shape.at(1);

	// TODO: Port sort.py its algorithm here
	// pixels[0] = 42.0f;

	uint64_t attemped_swaps = 0;
	uint64_t prev_attemped_swaps = 0;

	int saved_results = 0;
	(void)saved_results; // TODO: Use

	const std::filesystem::path output_npy_path = get_output_npy_path(
		args.output_npy_path,
		args.no_overwriting_output,
		args.saved_image_leading_zero_count,
		saved_results
	);

	auto last_printed_time = std::chrono::steady_clock::now();

	assert(signal(SIGINT, sigint_handler_running) != SIG_ERR);
	while (running)
	{
		// TODO: Make sure getting the time *every single loop* here isn't too slow
		const auto now = std::chrono::steady_clock::now();

		if (now > last_printed_time + std::chrono::seconds(args.seconds_between_saves))
		{
			const std::filesystem::path output_npy_path = get_output_npy_path(
				args.output_npy_path,
				args.no_overwriting_output,
				args.saved_image_leading_zero_count,
				saved_results
			);

			save_result(pixels, arr.shape, output_npy_path);
			saved_results += 1;

			print_status(saved_results, prev_attemped_swaps, attemped_swaps, start_time);

			last_printed_time = std::chrono::steady_clock::now();
			prev_attemped_swaps = attemped_swaps;
		}
	}

	save_result(pixels, arr.shape, output_npy_path);
	saved_results += 1;

	print_status(saved_results, prev_attemped_swaps, attemped_swaps, start_time);

	std::cout << "Gootbye" << std::endl;

	return EXIT_SUCCESS;
}
